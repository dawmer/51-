C51 COMPILER V9.54   WD                                                                    04/16/2021 20:43:46 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE WD
OBJECT MODULE PLACED IN .\wd.obj
COMPILER INVOKED BY: D:\keil5\C51\BIN\C51.EXE ..\万年历\wd.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\wd.lst)
                    - TABS(2) OBJECT(.\wd.obj)

line level    source

   1          /*******************************************************************************
   2          注意事项：
   3          根据自己使用的LCD1602是否带有转接板，如果带有转接板的即为4位，需在LCD.H头文件中
   4          将宏#define LCD1602_4PINS打开，我们这里使用的LCD1602是8位，所以默认将该宏注释。
   5          
   6          接线说明：（开发攻略每个实验章节内的实验现象都有对应的接线图说明）
   7          LCD1602接线参考LCD1602液晶显示实验接线图
   8          DS18B20传感器接线参考DS18B20温度传感器实验接线图
   9          
  10          
  11          
  12          实验操作：
  13          LCD1602上显示采集的温度，同时
  14          打开串口调试助手，将串口波特率选择4800，打开串口，此时在串口上就会显示采集的温度，串口截图参考文件夹下。
  15          *******************************************************************************/
  16          
  17          #include<reg52.h>
  18          #include"lcd.h"
  19          #include"temp.h"
  20          sbit RST=P3^5;
  21          uchar CNCHAR[6] = "摄氏度";
  22          void LcdDisplay(int);
  23          void UsartConfiguration();
  24          /*******************************************************************************
  25          * 函数名         : main
  26          * 函数功能       : 主函数
  27          * 输入           : 无
  28          * 输出           : 无
  29          *******************************************************************************/
  30          void delay(long int j)
  31          {
  32   1        while(j--);
  33   1      }
  34          void LCD_posh(uchar x,uchar y)
  35          {
  36   1        uchar pos;
  37   1        if(x==0)x=0x80;
  38   1        else if(x==1)x=0x90;
  39   1        else if(x==2)x=0x88;
  40   1        else if(x==3)x=0x98;
  41   1        pos=x+y;
  42   1        LcdWriteCom(pos);
  43   1      }
  44          void wdh()
  45          {
  46   1        UsartConfiguration();
  47   1        LCD_posh(2,7);  //写地址 80表示初始地址
  48   1        LcdWriteData('C');
  49   1        RST = 1;
  50   1          LcdDisplay(Ds18b20ReadTemp());
  51   1      //    Delay1ms(1000);//1s钟刷一次
  52   1      }
  53          
  54          /*******************************************************************************
C51 COMPILER V9.54   WD                                                                    04/16/2021 20:43:46 PAGE 2   

  55          * 函数名         : LcdDisplay()
  56          * 函数功能       : LCD显示读取到的温度
  57          * 输入           : v
  58          * 输出           : 无
  59          *******************************************************************************/
  60          
  61          void LcdDisplay(int temp)    //lcd显示
  62          {
  63   1          
  64   1          unsigned char i, datas[] = {0, 0, 0, 0, 0}; //定义数组
  65   1        float tp;  
  66   1        if(temp< 0)       //当温度值为负数
  67   1          {
  68   2          LCD_posh(2,3);      //写地址 80表示初始地址
  69   2          SBUF='-';//将接收到的数据放入到发送寄存器
  70   2          while(!TI);              //等待发送数据完成
  71   2          TI=0;            //清除发送完成标志位
  72   2            LcdWriteData('-');      //显示负
  73   2          //因为读取的温度是实际温度的补码，所以减1，再取反求出原码
  74   2          temp=temp-1;
  75   2          temp=~temp;
  76   2          tp=temp;
  77   2          temp=tp*0.0625*100+0.5; 
  78   2          //留两个小数点就*100，+0.5是四舍五入，因为C语言浮点数转换为整型的时候把小数点
  79   2          //后面的数自动去掉，不管是否大于0.5，而+0.5之后大于0.5的就是进1了，小于0.5的就
  80   2          //算由?.5，还是在小数点后面。
  81   2       
  82   2          }
  83   1        else
  84   1          {     
  85   2           LCD_posh(2,3);     //写地址 80表示初始地址
  86   2            LcdWriteData('+');    //显示正
  87   2          SBUF='+';//将接收到的数据放入到发送寄存器
  88   2          while(!TI);              //等待发送数据完成
  89   2          TI=0;            //清除发送完成标志位
  90   2          tp=temp;//因为数据处理有小数点所以将温度赋给一个浮点型变量
  91   2          //如果温度是正的那么，那么正数的原码就是补码它本身
  92   2          temp=tp*0.0625*100+0.5; 
  93   2          //留两个小数点就*100，+0.5是四舍五入，因为C语言浮点数转换为整型的时候把小数点
  94   2          //后面的数自动去掉，不管是否大于0.5，而+0.5之后大于0.5的就是进1了，小于0.5的就
  95   2          //算加上0.5，还是在小数点后面。
  96   2        }
  97   1        datas[0] = temp / 10000;
  98   1        datas[1] = temp % 10000 / 1000;
  99   1        datas[2] = temp % 1000 / 100;
 100   1        datas[3] = temp % 100 / 10;
 101   1        datas[4] = temp % 10;
 102   1      
 103   1        LCD_posh(2,4) ;     //写地址 80表示初始地址
 104   1        LcdWriteData('0'+datas[0]); //百位 
 105   1        SBUF = '0'+datas[0];//将接收到的数据放入到发送寄存器
 106   1        while (!TI);               //等待发送数据完成
 107   1        TI = 0;
 108   1        LcdWriteData('0'+datas[1]); //十位
 109   1        SBUF = '0'+datas[1];//将接收到的数据放入到发送寄存器
 110   1        while (!TI);               //等待发送数据完成
 111   1        TI = 0;
 112   1        LcdWriteData('0'+datas[2]); //个位 
 113   1        SBUF = '0'+datas[2];//将接收到的数据放入到发送寄存器
 114   1        while (!TI);               //等待发送数据完成
 115   1        TI = 0;
 116   1        LcdWriteData('.');    //显示 ‘.’
C51 COMPILER V9.54   WD                                                                    04/16/2021 20:43:46 PAGE 3   

 117   1        SBUF = '.';//将接收到的数据放入到发送寄存器
 118   1        while (!TI);               //等待发送数据完成
 119   1        TI = 0;
 120   1        LcdWriteData('0'+datas[3]); //显示小数点  
 121   1        SBUF = '0'+datas[3];//将接收到的数据放入到发送寄存器
 122   1        while (!TI);               //等待发送数据完成
 123   1        TI = 0;
 124   1        LcdWriteData('0'+datas[4]); //显示小数点 
 125   1        SBUF = '0'+datas[4];//将接收到的数据放入到发送寄存器
 126   1        while (!TI);               //等待发送数据完成
 127   1        TI = 0;
 128   1        for(i=0; i<6; i++)
 129   1        {
 130   2          SBUF = CNCHAR[i];//将接收到的数据放入到发送寄存器
 131   2          while (!TI);               //等待发送数据完成
 132   2          TI = 0;
 133   2        }
 134   1      
 135   1         
 136   1      }
 137          /*******************************************************************************
 138          * 函 数 名         :UsartConfiguration()
 139          * 函数功能       :设置串口
 140          * 输    入         : 无
 141          * 输    出         : 无
 142          *******************************************************************************/
 143          
 144          void UsartConfiguration()
 145          {
 146   1        SCON=0X50;      //设置为工作方式1
 147   1        TMOD=0X20;      //设置计数器工作方式2
 148   1        PCON=0X80;      //波特率加倍
 149   1        TH1=0XF3;       //计数器初始值设置，注意波特率是4800的
 150   1        TL1=0XF3;
 151   1      //  ES=1;           //打开接收中断
 152   1      //  EA=1;           //打开总中断
 153   1        TR1=1;          //打开计数器
 154   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    471    ----
   CONSTANT SIZE    =      5    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      6      15
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
